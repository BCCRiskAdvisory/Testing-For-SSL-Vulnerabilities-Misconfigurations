#!../../Custom_Python/build/bin/python2
# Description: This script will test to see if the target site is vulnerable to ssl poodle attacks
# Author: Zach Fleming
# Date: 18/04/2018


# Import The Relevant Libraries
import socket # connecting to hosts
import ssl # ssl protocols
from termcolor import colored # needed for colored print
import os
import traceback

# This Class Will Test A Url To See if it's vulnerable to the poodle attack
class ssl_poodle():
	
	# Global Variables --> Used for Logic at runtime
	success_list = [] # all successful connections will be added to this list which at the end of runtime will be written to the result file 
	manual_recheck_list = [] # all unsuccessful connections will be added to this list which at the end of runtime will be written to the result file 
	
	# Ciphers Gotten From Nessus
	CIPHERS = ('ADH-AES128-SHA:ADH-AES256-SHA:ADH-CAMELLIA128-SHA:ADH-CAMELLIA256-SHA:ADH-DES-CBC3-SHA:ADH-DES-CBC-SHA:ADH-SEED-SHA:AECDH-AES128-SHA:AECDH-AES256-SHA:AECDH-DES-CBC3-SHA:AES128-SHA:AES256-SHA:CAMELLIA128-SHA:CAMELLIA256-SHA:DES-CBC3-SHA:DES-CBC-SHA:DH-AES128-SHA256:DH-AES256-SHA256:DH-CAMELLIA128-SHA256:DH-CAMELLIA256-SHA256:DH-DSS-AES128-SHA:DH-DSS-AES128-SHA256:DH-DSS-AES256-SHA:DH-DSS-AES256-SHA256:DH-DSS-CAMELLIA128-SHA:DH-DSS-CAMELLIA128-SHA256:DH-DSS-CAMELLIA256-SHA:DH-DSS-CAMELLIA256-SHA256:DH-DSS-DES-CBC3-SHA:DH-DSS-DES-CBC-SHA:DH-DSS-SEED-SHA:DHE-DSS-AES128-SHA:DHE-DSS-AES128-SHA256:DHE-DSS-AES256-SHA:DHE-DSS-AES256-SHA256:DHE-DSS-CAMELLIA128-SHA:DHE-DSS-CAMELLIA128-SHA256:DHE-DSS-CAMELLIA256-SHA:DHE-DSS-CAMELLIA256-SHA256:DHE-DSS-SEED-SHA:DHE-PSK-3DES-CBC168-SHA:DHE-PSK-AES128-SHA:DHE-PSK-AES128-SHA256:DHE-PSK-AES256-SHA:DHE-PSK-AES256-SHA384:DHE-RSA-AES128-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES256-SHA:DHE-RSA-AES256-SHA256:DHE-RSA-CAMELLIA128-SHA:DHE-RSA-CAMELLIA128-SHA256:DHE-RSA-CAMELLIA256-SHA:DHE-RSA-CAMELLIA256-SHA256:DHE-RSA-SEED-SHA:DH-RSA-AES128-SHA:DH-RSA-AES128-SHA256:DH-RSA-AES256-SHA:DH-RSA-AES256-SHA256:DH-RSA-CAMELLIA128-SHA:DH-RSA-CAMELLIA128-SHA256:DH-RSA-CAMELLIA256-SHA:DH-RSA-CAMELLIA256-SHA256:DH-RSA-DES-CBC3-SHA:DH-RSA-DES-CBC-SHA:DH-RSA-SEED-SHA:ECDH-ECDSA-AES128-SHA:ECDH-ECDSA-AES128-SHA256:ECDH-ECDSA-AES256-SHA:ECDH-ECDSA-AES256-SHA384:ECDH-ECDSA-DES-CBC3-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA256:ECDHE-ECDSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA384:ECDHE-ECDSA-DES-CBC3-SHA:ECDHE-PSK-3DES168-SHA:ECDHE-PSK-AES128-SHA:ECDHE-PSK-AES128-SHA256:ECDHE-PSK-AES256-SHA:ECDHE-PSK-AES256-SHA384:ECDHE-RSA-AES128-SHA:ECDHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-DES-CBC3-SHA:ECDH-RSA-AES128-SHA:ECDH-RSA-AES128-SHA256:ECDH-RSA-AES256-SHA:ECDH-RSA-AES256-SHA384:ECDH-RSA-DES-CBC3-SHA:EDH-DSS-DES-CBC3-SHA:EDH-DSS-DES-CBC-SHA:EDH-RSA-DES-CBC3-SHA:EDH-RSA-DES-CBC-SHA:EXP1024-DES-CBC-SHA:EXP1024-DHE-DSS-DES-CBC-SHA:EXP1024-RC2-CBC-MD5:EXP-ADH-DES-CBC-SHA:EXP-DES-CBC-SHA:EXP-DH-DSS-DES-CBC-SHA:EXP-DH-RSA-DES-CBC-SHA:EXP-EDH-DSS-DES-CBC-SHA:EXP-EDH-RSA-DES-CBC-SHA:EXP-KRB5-DES-CBC-MD5:EXP-KRB5-DES-CBC-SHA:EXP-KRB5-RC2-CBC-MD5:EXP-KRB5-RC2-CBC-SHA:EXP-RC2-CBC-MD5:IDEA-CBC-SHA:KRB5-DES-CBC3-MD5:KRB5-DES-CBC3-SHA:KRB5-DES-CBC-MD5:KRB5-DES-CBC-SHA:KRB5-IDEA-CBC-MD5:KRB5-IDEA-CBC-SHA:PSK-3DES-EDE-CBC-SHA:PSK-AES128-CBC-SHA:PSK-AES128-SHA256:PSK-AES256-CBC-SHA:PSK-AES256-SHA384:RSA-AES128-SHA256:RSA-AES256-SHA256:RSA-CAMELLIA128-SHA256:RSA-CAMELLIA256-SHA256:RSA-PSK-3DES-CBC168-SHA:RSA-PSK-AES128-SHA:RSA-PSK-AES128-SHA256:RSA-PSK-AES256-SHA:RSA-PSK-AES256-SHA384:SEED-SHA:SRP-3DES168-SHA:SRP-AES128-SHA:SRP-AES256-SHA:SRP-DSS-3DES168-SHA:SRP-DSS-AES128-SHA:SRP-DSS-AES256-SHA:SRP-RSA-3DES168-SHA:SRP-RSA-AES128-SHA:SRP-RSA-AES256-SHA')
	
	# Initialize class
	def __init__(self,filename):
		
		# If The User Selected Option 2
		if ".txt" in filename:
			# Open File Containing The Client Info i.e. ip & port
			with open(filename, 'r') as f:
				ip_list = f.readlines()
				
		# If the User Selected Option 1
		else:
			ip_list = [filename]
			
		i = 0 # used as counter to iterate through the list
		protocol = ssl.PROTOCOL_SSLv3 # define the ssl protocol to be used
				
		# While loop to iterate through the client list and test is it vulnerable to the beast attack
		while i<len(ip_list):
			try:
				client = ip_list[i]	# i is used to iterate through the list of clients 
				client = client.strip() # strip whitespace
				host = client.split(":")[1] # remove the scheme from the url i.e. https so you would be left with //whatever.com:443
				host = host[2:] # remove // from the url
				port = client.split(":")[2] # Get port number
				port = int(port) # convert string to port
				
				
				# CREATE SOCKET
				sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
				sock.settimeout(5) # set timeout to 5 seconds
				# WRAP Socket --> Convert to SSL and specify protocol Version
				wrappedSocket = ssl.wrap_socket(sock, ssl_version=protocol, ciphers = self.CIPHERS)
				
				# Connect to client with ip x and port y
				wrappedSocket.connect((host, port))
				cipher = wrappedSocket.cipher() # get cipher used to initate connection
				ssl_version =  wrappedSocket.version() # get the ssl version used to initate connection
				
				# Close the Connection
				wrappedSocket.close()
				
				# Successfully Connected So add to results
				print colored ("Successfully Connected To " + host + ":" + repr(port) + " Using " + ssl_version + " With CBC Cipher " + cipher[0] + " ...[VULNERABLE]" ,'green')
				self.success_list.append(client)
				
				i+=1 # increment counter --> go to next client
			except ssl.SSLError as e:
				#print (e) # print error code
				print colored("Exception checking for cbc ciphers raised --> Adding " + client + " to list for manual inpsection later",'red')
				self.manual_recheck_list.append(client)
				i +=1
				continue
			except Exception as e:
				print colored("Exception checking for cbc ciphers raised --> Adding " + client + " to list for manual inpsection later",'red')
				self.manual_recheck_list.append(client)
				i +=1
				continue
				
				
		# Display output to the user 

		
		print colored("\n" + 70 * '-','blue')
		print colored('		RESULTS','cyan',attrs=['bold'])
		print colored(70 * '-','blue')
	
		if len(self.success_list) !=0:
			print colored("\nSuccessfully Established A SSLv3 Connection With A CBC Cipher Indicating Client is Vulnerable To POODLE",'green')
			for element in self.success_list:
				
				print colored(element,'yellow')

		if len(self.manual_recheck_list) !=0:
			print colored("\nCould not Establish A SSLv3 Connection With A CBC Cipher--> Need To Be MAnually Verified",'red')

			for element in self.manual_recheck_list:
				print colored(element,'yellow')

# Main Function
def main():
	
	# Display tool info to the user
	print colored(30 * "-", 'cyan')
	print colored("\nSSL POODLE Detector", 'cyan',  attrs=['bold'])
	print colored(30 * "-", 'cyan')
	print colored("Author: Zach Fleming", 'yellow')
	print colored("Date: 19/04/18", 'green')
	print colored("\nDescription: Determines if a remote service uses SSL Ciphers that are vulnerable to the Padding Oracle On Downgraded Legacy Encryption (POODLE) Attack.\nIf it does support an ssl cipher that is vulnerable, it may allow for a man in the middle exploit. This works by attackers taking advantage of clients fallback to SSLv3.\nIf an attacker successfully exploits this vulnerability it make allow them to view encrypted data in plaintext",'cyan')
		
	# While loop to ask user to select which option with basic error sanitization
	while True:
		
		# Display Options To The User
		print colored("\nPlease Select One of The Following Options ",'cyan',attrs=['bold'])
		print colored("  1. Single Url",'yellow')
		print colored("  2. File With List of Urls",'yellow')
	
	
		choice = raw_input("\nOption 1 or Option 2: ")
		
		# If user only wishes to test for one url
		if choice == "1":
			os.system('cls' if os.name == 'nt' else 'clear') # Clear Screen
			print colored("Please Enter URL in the following format http://www.whatever.come:443",'cyan')
			
			# Try statement to handle any unexpected errors
			try:
				target_url = raw_input("URL: ") # get url from the user
				ssl_poodle(target_url) # pass url to class
				break
			# catch errors
			except Exception as e:
				print colored("! Error Something Unexpected Occured " + str(e),'red',attrs=['bold'])
				print traceback.print_exc()
		
		# If User wishes to scan a text file conataining a list of urls
		elif choice == "2":
			os.system('cls' if os.name == 'nt' else 'clear') # Clear Screen
			print colored("\nNote text file must be in the following format url and port on each line i.e.",'yellow',attrs=['bold'])
			print colored("\nhttp://www.whatever.com:80\nhttps://www.whatever.com:443'",'yellow')
			print colored("\nPlease Enter Filename including it's location i.e. '/user/Desktop/target_urls.txt'",'cyan')
			
			# Try statement to handle any unexpected errors
			try:
				target_filename = raw_input("Target File: ") # get url from the user
				ssl_poodle(target_filename) # pass url to class
				break
			# catch errors
			except Exception as e:
				print colored("! Error Something Unexpected Occured " + str(e),'red',attrs=['bold'])
				print traceback.print_exc()
				print colored("! Please Try Again",'red')
				
		else:
			os.system('cls' if os.name == 'nt' else 'clear') # Clear Screen
			print colored("! Invalid Option. Please Select Either Option 1 or Option 2",'red',attrs=['bold'])
			
	
main()
